# -*- coding: utf-8 -*-
"""solar_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WQqLzyWvrlTxtwG7Sy6-EG8fxp4EaVXQ
"""



import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import GlobalAveragePooling2D, Dense, Dropout

import tensorflow as tf
from tensorflow.keras.applications import ResNet50, EfficientNetB0
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, GlobalAveragePooling2D
from tensorflow.keras.optimizers import Adam
from sklearn.model_selection import train_test_split
from tensorflow.keras.initializers import HeNormal
from tensorflow.keras.layers import Dropout

print(tf.__version__)


# Set the path to your dataset and CSV file
image_dir = 'C:/Users/yousf/Downloads/solar_model/solar_model/images'  # Folder with solar panel images
csv_file = 'C:/Users/yousf/Downloads/solar_model/solar_model/Voc_Values.csv'  # CSV with image paths and voltage values

import pandas as pd

# Load the CSV file
df = pd.read_csv(csv_file)

# Inspect the DataFrame
print(df.head())

# Example DataFrame:
#        image_path      open_voltage
# 0    img1.jpg              22.5
# 1    img2.jpg              23.0
# 2    img3.jpg              21.8



import tensorflow as tf
from tensorflow.keras.preprocessing.image import load_img, img_to_array

# Function to preprocess images and return them with their corresponding voltage
class SolarImageDataGenerator(tf.keras.utils.Sequence):
    def __init__(self, dataframe, batch_size, image_dir, target_size=(224, 224), shuffle=True):
        self.dataframe = dataframe
        self.batch_size = batch_size
        self.image_dir = image_dir
        self.target_size = target_size
        self.shuffle = shuffle
        self.on_epoch_end()

    def __len__(self):
        return len(self.dataframe) // self.batch_size

    def __getitem__(self, index):
        # Generate indices of the batch
        batch_indices = self.indices[index * self.batch_size:(index + 1) * self.batch_size]

        # Get the images and labels for the batch
        batch_df = self.dataframe.iloc[batch_indices]
        images = np.array([self.load_image(img_path) for img_path in batch_df['image_path']])
        labels = batch_df['Voltage'].values

        return images, labels

    def on_epoch_end(self):
        # Shuffle the data at the end of each epoch if required
        self.indices = np.arange(len(self.dataframe))
        if self.shuffle:
            np.random.shuffle(self.indices)

    def load_image(self, img_path):
        # Load and preprocess the image
        img = load_img(self.image_dir + img_path, target_size=self.target_size)
        img = img_to_array(img)
        img /= 255.0  # Normalize pixel values to [0, 1]
        return img

# Example usage
batch_size = 16
train_df, val_df = train_test_split(df, test_size=0.2, random_state=42)  # Split the dataset

train_generator = SolarImageDataGenerator(train_df, batch_size=batch_size, image_dir=image_dir)
val_generator = SolarImageDataGenerator(val_df, batch_size=batch_size, image_dir=image_dir)

optimizer = Adam(learning_rate=1e-4, clipvalue=1.0)  # Clip gradients to a maximum value

# Load ResNet50 or EfficientNet as the base model
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224,3))
#base_model = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Freeze the base model
base_model.trainable = False

# Build the full model for regression
model = Sequential([
    base_model,
    GlobalAveragePooling2D(),
    Dropout(0.5),
    Dense(128, activation='relu'),
    Dropout(0.2),
    Dense(1, activation='linear')  # Output a single continuous value (voltage)
])
# Check model layers and their shapes
#model.add(Dense(128, activation='relu', kernel_initializer=HeNormal()))
#model.add(Dropout(0.5))  # Add dropout layer to reduce overfitting

# Compile the model
model.compile(optimizer=optimizer, loss='mean_squared_error', metrics=['mae'])

# Print model summary
model.summary()

# Train the model
history = model.fit(
    train_generator,
    validation_data=val_generator,
    epochs=10,  # Adjust the number of epochs as necessary
    verbose=1
)

# Evaluate the model on validation data
val_loss, val_mae = model.evaluate(val_generator)
print(f'Validation MAE: {val_mae}')

# # Save the trained model
# model.save('/content/drive/MyDrive/solar_voltage_regression_model.h5')

# # # Plot training & validation loss and MAE
# plt.plot(history.history['mae'], label='Train MAE')
# plt.plot(history.history['val_mae'], label='Val MAE')
# plt.title('Mean Absolute Error')
# plt.xlabel('Epochs')
# plt.ylabel('MAE')
# plt.legend()
# plt.show()

# from tensorflow.keras.preprocessing.image import load_img, img_to_array
# import matplotlib.pyplot as plt
# import matplotlib.image as mpimg
# import numpy as np

# # Load and preprocess the image
# img_path = '/content/drive/MyDrive/solar_dataset/images/images/_20240905_121838.jpg'

# # Adjust target_size according to your model's input shape
# img = load_img(img_path, target_size=(224, 224))  # For ResNet/EfficientNet models, use (224, 224)
# plt.imshow(img)
# img = img_to_array(img)  # Convert the image to a numpy array
# img = img / 255.0        # Normalize pixel values to [0, 1]
# img = np.expand_dims(img, axis=0)  # Add a batch dimension

# # Predict using the trained model
# predicted_output = model.predict(img)

# #img = mpimg.imread(image_path)

# plt.axis('off')  # To hide the axis
# plt.show()
# # Print the output
# print('Predicted Output VoC:', (1+abs(float(predicted_output[0]))))
# print('Actual Output VoC:', (1+abs(float(df['Voltage'][100]))))